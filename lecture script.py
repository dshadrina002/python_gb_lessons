# создание списка. Можно менять эл-ты в списке
list_1 = [1, 2, 3]

# добавление эл-та в конец списка
list_1.append(8)

# простой цикл для добавления элементов в список
list_1 = []
for i in range(5):
    list_1.append(i)
    print(list_1)

# удаление последнего элемента списка
list_1 = [1, 2 , 4]
list_1.pop()

# удаление конктретного элемента списка по индексу
list_1.pop(0)

# добавление элемента в список - insert(аргумент, значение аргумента)
list_1.insert(0, 12)

# вывод элементов из списка
list_1[:] #весь список
list_1[1] #индекс из списка
list_1[:2] #ограничиваем вывод из списка снизу номером эл-та
list_1[2:] #ограничиваем вывод из списка сверху номером эл-та

# кортеж - неизменяемый список
t = (1, 2, 3,) # обязательно запятая в конце перечисления если один элемент

# словарь - список с заданным ключом для поиска, т.е. каждому элементу соответсвует какой-то ключ
some_dict = {}
d = {}
d['q'] = 'qwerty' # добавление нового эл-та в словарь
d['w'] = 'werty'
d['e'] = 'erty'
print(d)
# ключ можно добавить. Если ключ уже есть в словаре, то перезапишется значение ключа.
# по ключу можно вывести значение. наоборот нельзя
print(d['q'])

# вывод элементов словаря по формату
for i in d:
    print('{}: {}'.format(i, d[i]))

# генератор списков с условием
list_2 = [i for i in range (1, 21) if i % 2 == 0 ]
print(list_2)

# строки - неизменяемый тип данных
some_str = 'hello world'
print(len(some_str))
print(some_str(::-1)) #переворот строки в обратном порядке

for letter in some_str:
    print(letter)

for i in range(o, len(some_str)):
    print(some_str[i])

# множество - похож на список, но нет индексации и элементы должны быть уникальными, порядок нарушается, Но искать элементы намного быстрее по хэшу
some_set = set()
some_set.add(1) # добавление элемента в множество

list = [random.randint(min, max) for i in range(n)] # создание списка из рандомных числе, нужно импортировать библиотеку random

# Разница return vs print
def sq1(x):
    print(x**2) # эта только принтует, не сохраняет значение в переменную
def sq2(x):
    return x**2
res = sq2(20) # эта сохраняет значение функ-и в переменную, и уже печатаем переменную
print(res)

# map - функция, к-ая применяет какую-то другую функцию к объектам коллекции
some_list = [1, 2, 3, 4, 5]
new_list = list(map(str, some_list))
print(new_list)

# lambda - функция, к-ая не сохранеят значение исполняемой операции. Как правило делает разовую операцию внутри другой функции.
def c(x):
    return x ** 3

some_list = [1, 2, 3, 4, 5]
new_list = list(map(lambda x: x ** 3, some_list)) # здесь лямда и с выполняют одно и то же
print(new_list)

some_list = [1, 2, 3, 4, 5]
new_list = list(map(lambda x: x ** 2 if x % 2 == 0 else x ** 3, some_list)) # сложное условие в лямбе
print(new_list)

# фильтр - извлекает данные из коллекции по правилу
def even(a):
    return a % 2 == 0
some_list = [1, 2, 3, 4, 5]
new_list = list(filter(lambda a: a % 2 == 0, some_list))
print(new_list)